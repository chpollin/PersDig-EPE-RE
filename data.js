// ========================================
// EPE - Edition Production Environment
// Core JavaScript Implementation
// ========================================

// Global namespace
const EPE = {
   version: '0.1-alpha',
   debug: true,
   currentProject: null,
   preferences: {},
   tokenizers: {},
   exporters: {},
   storage: {},
   ui: {},
   data: {}
};

// ========================================
// 1. SAMPLE DATA LOADER
// ========================================

EPE.data.samples = {
   projects: [
       {
           id: 'persian-poetry',
           name: 'Persian Poetry Collection - Hafez',
           type: 'Multi-witness Edition',
           schema: 'SQE Compatible',
           created: '2024-12-18',
           witnesses: [
               {
                   id: 'MS_001',
                   label: 'Paris BnF Persan 1234',
                   status: 'complete',
                   date: '1453 CE',
                   folios: 156,
                   scribe: 'Muhammad ibn Ahmad',
                   origin: 'Shiraz',
                   script: 'Nasta\'liq',
                   isBase: true,
                   text: 'در این کتاب مبارک که نسخه کامل دیوان حافظ شیرازی است\nابیات زیبای غزلیات با خط نستعلیق نوشته شده\nهر بیت در این مجموعه گنجینه ای از معرفت است',
                   tokens: null, // Will be generated by tokenizer
                   metadata: {
                       language: 'fa',
                       direction: 'rtl',
                       confidence: 0.95
                   }
               },
               {
                   id: 'MS_002',
                   label: 'Oxford Bodl. Pers. 567',
                   status: 'complete',
                   date: '1498 CE',
                   folios: 143,
                   scribe: 'Ali ibn Husayn',
                   origin: 'Isfahan',
                   script: 'Nasta\'liq',
                   isBase: false,
                   text: 'در این کتاب شریف که نسخه کامل دیوان حافظ شیرازی است\nابیات زیبای غزلیات با خط نستعلیق نوشته شده\nهر بیت در این مجموعه گنجینه ای از حکمت است',
                   tokens: null,
                   metadata: {
                       language: 'fa',
                       direction: 'rtl',
                       confidence: 0.92
                   }
               },
               {
                   id: 'MS_003',
                   label: 'Berlin SBB Or. 890',
                   status: 'fragment',
                   date: '1512 CE',
                   folios: 89,
                   scribe: 'Unknown',
                   origin: 'Herat',
                   script: 'Naskh',
                   isBase: false,
                   text: 'در این کتاب مبارک که [gap] دیوان حافظ شیرازی است\n[gap] غزلیات با خط نستعلیق نوشته شده\nهر بیت در این مجموعه گنجینه ای از معرفت است',
                   tokens: null,
                   metadata: {
                       language: 'fa',
                       direction: 'rtl',
                       confidence: 0.78
                   }
               }
           ],
           sections: [
               { id: 'ch1', title: 'Chapter 1', start: 0, end: 50 },
               { id: 'ch2', title: 'Chapter 2', start: 51, end: 100 },
               { id: 'ch3', title: 'Chapter 3', start: 101, end: 150 }
           ]
       },
       {
           id: 'arabic-scientific',
           name: 'Arabic Scientific Manuscripts - Al-Biruni',
           type: 'Critical Edition',
           schema: 'SQE Compatible',
           created: '2024-12-18',
           witnesses: [
               {
                   id: 'MS_004',
                   label: 'Cairo Dar al-Kutub 234',
                   status: 'complete',
                   date: '1156 CE',
                   folios: 234,
                   scribe: 'Ibn al-Nadim',
                   origin: 'Cairo',
                   script: 'Naskh',
                   isBase: true,
                   text: 'بسم الله الرحمن الرحيم\nهذا كتاب في علم الفلك والنجوم\nوضعه العالم الجليل أبو الريحان البيروني',
                   tokens: null,
                   metadata: {
                       language: 'ar',
                       direction: 'rtl',
                       confidence: 0.94
                   }
               }
           ]
       },
       {
           id: 'mixed-manuscript',
           name: 'Mixed Latin-Arabic Philosophical Text',
           type: 'Diplomatic Edition',
           schema: 'SQE Compatible',
           created: '2024-12-18',
           witnesses: [
               {
                   id: 'MS_005',
                   label: 'Vatican Ar. 123',
                   status: 'complete',
                   date: '1234 CE',
                   folios: 178,
                   scribe: 'Johannes de Sacrobosco',
                   origin: 'Toledo',
                   script: 'Mixed',
                   isBase: true,
                   text: 'Incipit liber de sphaera mundi\nوهذا الكتاب في علم الهيئة\nQuod terra sit rotunda probatur',
                   tokens: null,
                   metadata: {
                       language: 'mixed',
                       direction: 'mixed',
                       confidence: 0.88
                   }
               }
           ]
       }
   ]
};

EPE.data.loadSampleProject = function(projectId) {
   const project = this.samples.projects.find(p => p.id === projectId);
   if (!project) {
       console.error('Sample project not found:', projectId);
       return false;
   }
   
   // Deep clone to avoid modifying sample data
   EPE.currentProject = JSON.parse(JSON.stringify(project));
   
   // Auto-tokenize all witnesses
   EPE.currentProject.witnesses.forEach(witness => {
       witness.tokens = EPE.tokenizers.tokenize(witness.text, witness.metadata.language);
   });
   
   // Update UI
   EPE.ui.updateWitnessList();
   EPE.ui.updateMainView();
   EPE.ui.showNotification('Sample project loaded: ' + project.name, 'success');
   
   // Save to localStorage
   EPE.storage.saveProject();
   
   return true;
};

// ========================================
// 2. TOKENIZATION ENGINE
// ========================================

EPE.tokenizers = {
   patterns: {
       persian: {
           word: /[\u0600-\u06FF\u0750-\u077F\u08A0-\u08FF\uFB50-\uFDFF\uFE70-\uFEFF]+/g,
           punctuation: /[.،؛:؟!]/g,
           number: /[\u06F0-\u06F9]+/g,
           whitespace: /\s+/g
       },
       arabic: {
           word: /[\u0600-\u06FF\u0750-\u077F\u08A0-\u08FF\uFB50-\uFDFF\uFE70-\uFEFF]+/g,
           punctuation: /[.،؛:؟!]/g,
           number: /[\u0660-\u0669]+/g,
           whitespace: /\s+/g
       },
       latin: {
           word: /\b[A-Za-z]+\b/g,
           punctuation: /[.,:;!?]/g,
           number: /\b\d+\b/g,
           whitespace: /\s+/g
       },
       mixed: {
           word: /[\u0600-\u06FF\u0750-\u077F\u08A0-\u08FF\uFB50-\uFDFF\uFE70-\uFEFF]+|\b[A-Za-z]+\b/g,
           punctuation: /[.،؛:؟!,:;?]/g,
           number: /[\u0660-\u0669\u06F0-\u06F9]+|\b\d+\b/g,
           whitespace: /\s+/g
       }
   },
   
   settings: {
       includePunctuation: true,
       preserveLineBreaks: true,
       includeNumbers: true,
       customPattern: null,
       minTokenLength: 1,
       maxTokenLength: 50
   },
   
   tokenize: function(text, language = 'auto') {
       if (!text) return [];
       
       // Auto-detect language if needed
       if (language === 'auto') {
           language = this.detectLanguage(text);
       }
       
       const pattern = this.patterns[language] || this.patterns.mixed;
       const tokens = [];
       let tokenId = 0;
       
       // Split by lines first if preserving line breaks
       const lines = this.settings.preserveLineBreaks ? text.split('\n') : [text];
       
       lines.forEach((line, lineIndex) => {
           // Handle gaps
           if (line.includes('[gap]')) {
               tokens.push({
                   id: `T${tokenId++}`,
                   text: '[gap]',
                   type: 'gap',
                   line: lineIndex,
                   position: 0,
                   length: 5
               });
               line = line.replace('[gap]', '');
           }
           
           // Extract words
           let matches = line.matchAll(pattern.word);
           for (let match of matches) {
               if (match[0].length >= this.settings.minTokenLength && 
                   match[0].length <= this.settings.maxTokenLength) {
                   tokens.push({
                       id: `T${tokenId++}`,
                       text: match[0],
                       type: 'word',
                       line: lineIndex,
                       position: match.index,
                       length: match[0].length,
                       normalized: this.normalize(match[0], language)
                   });
               }
           }
           
           // Extract punctuation if enabled
           if (this.settings.includePunctuation) {
               matches = line.matchAll(pattern.punctuation);
               for (let match of matches) {
                   tokens.push({
                       id: `T${tokenId++}`,
                       text: match[0],
                       type: 'punctuation',
                       line: lineIndex,
                       position: match.index,
                       length: match[0].length
                   });
               }
           }
           
           // Extract numbers if enabled
           if (this.settings.includeNumbers) {
               matches = line.matchAll(pattern.number);
               for (let match of matches) {
                   tokens.push({
                       id: `T${tokenId++}`,
                       text: match[0],
                       type: 'number',
                       line: lineIndex,
                       position: match.index,
                       length: match[0].length
                   });
               }
           }
       });
       
       // Sort tokens by position
       tokens.sort((a, b) => {
           if (a.line !== b.line) return a.line - b.line;
           return a.position - b.position;
       });
       
       // Add sequential numbering
       tokens.forEach((token, index) => {
           token.sequenceNumber = index;
           token.globalId = `CH${1}_S${1}_L${token.line + 1}_T${index + 1}`;
       });
       
       return tokens;
   },
   
   detectLanguage: function(text) {
       const arabicPersianChars = (text.match(/[\u0600-\u06FF]/g) || []).length;
       const latinChars = (text.match(/[A-Za-z]/g) || []).length;
       
       const total = arabicPersianChars + latinChars;
       if (total === 0) return 'mixed';
       
       const arabicPersianRatio = arabicPersianChars / total;
       
       if (arabicPersianRatio > 0.8) {
           // Further distinguish between Arabic and Persian
           const persianSpecific = (text.match(/[پچژگ]/g) || []).length;
           return persianSpecific > 0 ? 'persian' : 'arabic';
       } else if (arabicPersianRatio < 0.2) {
           return 'latin';
       } else {
           return 'mixed';
       }
   },
   
   normalize: function(text, language) {
       // Basic normalization rules
       let normalized = text;
       
       if (language === 'persian' || language === 'arabic') {
           // Remove Arabic diacritics
           normalized = normalized.replace(/[\u064B-\u0652\u0670]/g, '');
           // Normalize Arabic-Indic digits to Arabic numerals
           normalized = normalized.replace(/[\u0660-\u0669]/g, (match) => {
               return String.fromCharCode(match.charCodeAt(0) - 0x0660 + 0x0030);
           });
           // Normalize Persian digits
           normalized = normalized.replace(/[\u06F0-\u06F9]/g, (match) => {
               return String.fromCharCode(match.charCodeAt(0) - 0x06F0 + 0x0030);
           });
       }
       
       return normalized;
   },
   
   retokenize: function(witnessId) {
       if (!EPE.currentProject) return;
       
       const witness = EPE.currentProject.witnesses.find(w => w.id === witnessId);
       if (!witness) return;
       
       witness.tokens = this.tokenize(witness.text, witness.metadata.language);
       EPE.ui.updateTokenDisplay(witnessId);
       EPE.storage.saveProject();
       
       EPE.ui.showNotification(`Retokenized ${witness.label}`, 'success');
   },
   
   mergeTokens: function(tokenIds) {
       // Merge multiple tokens into one
       if (tokenIds.length < 2) return;
       
       const tokens = EPE.currentProject.witnesses[0].tokens;
       const toMerge = tokens.filter(t => tokenIds.includes(t.id));
       
       if (toMerge.length < 2) return;
       
       // Sort by position
       toMerge.sort((a, b) => a.sequenceNumber - b.sequenceNumber);
       
       // Create merged token
       const merged = {
           id: toMerge[0].id,
           text: toMerge.map(t => t.text).join(''),
           type: 'word',
           line: toMerge[0].line,
           position: toMerge[0].position,
           length: toMerge.reduce((sum, t) => sum + t.length, 0),
           merged: true,
           originalTokens: toMerge.map(t => t.id)
       };
       
       // Remove old tokens and insert merged
       const firstIndex = tokens.indexOf(toMerge[0]);
       tokens.splice(firstIndex, toMerge.length, merged);
       
       // Renumber
       tokens.forEach((token, index) => {
           token.sequenceNumber = index;
       });
       
       EPE.storage.saveProject();
       EPE.ui.updateTokenDisplay();
   },
   
   splitToken: function(tokenId, splitPosition) {
       const tokens = EPE.currentProject.witnesses[0].tokens;
       const tokenIndex = tokens.findIndex(t => t.id === tokenId);
       
       if (tokenIndex === -1) return;
       
       const token = tokens[tokenIndex];
       const text1 = token.text.substring(0, splitPosition);
       const text2 = token.text.substring(splitPosition);
       
       const newTokens = [
           {
               ...token,
               id: token.id,
               text: text1,
               length: text1.length
           },
           {
               ...token,
               id: `${token.id}_2`,
               text: text2,
               position: token.position + splitPosition,
               length: text2.length
           }
       ];
       
       tokens.splice(tokenIndex, 1, ...newTokens);
       
       // Renumber
       tokens.forEach((token, index) => {
           token.sequenceNumber = index;
       });
       
       EPE.storage.saveProject();
       EPE.ui.updateTokenDisplay();
   }
};

// ========================================
// 3. LOCAL STORAGE SYSTEM
// ========================================

EPE.storage = {
   keys: {
       currentProject: 'epe_current_project',
       preferences: 'epe_preferences',
       recentProjects: 'epe_recent_projects',
       annotations: 'epe_annotations',
       alignmentData: 'epe_alignment_data',
       exportHistory: 'epe_export_history',
       autoSaveBackup: 'epe_autosave_backup'
   },
   
   maxStorageSize: 5 * 1024 * 1024, // 5MB
   autoSaveInterval: 30000, // 30 seconds
   maxRecentProjects: 5,
   maxExportHistory: 10,
   
   init: function() {
       // Check localStorage availability
       if (!this.isAvailable()) {
           console.error('localStorage is not available');
           return false;
       }
       
       // Load preferences
       this.loadPreferences();
       
       // Load last project if exists
       const hasProject = this.loadProject();
       
       // Start auto-save
       this.startAutoSave();
       
       // Check storage quota
       this.checkStorageQuota();
       
       return hasProject;
   },
   
   isAvailable: function() {
       try {
           const test = '__localStorage_test__';
           localStorage.setItem(test, test);
           localStorage.removeItem(test);
           return true;
       } catch(e) {
           return false;
       }
   },
   
   saveProject: function() {
       if (!EPE.currentProject) return false;
       
       try {
           const projectData = {
               project: EPE.currentProject,
               timestamp: new Date().toISOString(),
               version: EPE.version
           };
           
           const serialized = JSON.stringify(projectData);
           
           // Check size
           if (serialized.length > this.maxStorageSize) {
               EPE.ui.showNotification('Project too large for localStorage', 'error');
               return false;
           }
           
           localStorage.setItem(this.keys.currentProject, serialized);
           
           // Update recent projects
           this.updateRecentProjects(EPE.currentProject);
           
           // Update UI
           EPE.ui.showSaveIndicator();
           
           return true;
       } catch(e) {
           console.error('Failed to save project:', e);
           EPE.ui.showNotification('Failed to save project', 'error');
           return false;
       }
   },
   
   loadProject: function() {
       try {
           const serialized = localStorage.getItem(this.keys.currentProject);
           if (!serialized) return false;
           
           const projectData = JSON.parse(serialized);
           EPE.currentProject = projectData.project;
           
           // Reconstruct token objects if needed
           if (EPE.currentProject.witnesses) {
               EPE.currentProject.witnesses.forEach(witness => {
                   if (witness.tokens && Array.isArray(witness.tokens)) {
                       // Tokens are already present
                   } else if (witness.text) {
                       // Retokenize if only text is present
                       witness.tokens = EPE.tokenizers.tokenize(
                           witness.text, 
                           witness.metadata.language
                       );
                   }
               });
           }
           
           EPE.ui.showNotification('Project loaded from local storage', 'success');
           return true;
       } catch(e) {
           console.error('Failed to load project:', e);
           return false;
       }
   },
   
   savePreferences: function() {
       try {
           const prefs = {
               language: document.querySelector('.language-switcher')?.value || 'EN',
               theme: EPE.preferences.theme || 'light',
               panelSizes: EPE.preferences.panelSizes || {},
               tokenSettings: EPE.tokenizers.settings,
               shortcuts: EPE.preferences.shortcuts || {},
               lastSaved: new Date().toISOString()
           };
           
           localStorage.setItem(this.keys.preferences, JSON.stringify(prefs));
           EPE.preferences = prefs;
           
           return true;
       } catch(e) {
           console.error('Failed to save preferences:', e);
           return false;
       }
   },
   
   loadPreferences: function() {
       try {
           const serialized = localStorage.getItem(this.keys.preferences);
           if (!serialized) return false;
           
           EPE.preferences = JSON.parse(serialized);
           
           // Apply preferences
           if (EPE.preferences.tokenSettings) {
               Object.assign(EPE.tokenizers.settings, EPE.preferences.tokenSettings);
           }
           
           return true;
       } catch(e) {
           console.error('Failed to load preferences:', e);
           return false;
       }
   },
   
   saveAnnotations: function(witnessId, tokenId, annotations) {
       try {
           const key = `${this.keys.annotations}_${witnessId}`;
           let allAnnotations = {};
           
           const existing = localStorage.getItem(key);
           if (existing) {
               allAnnotations = JSON.parse(existing);
           }
           
           allAnnotations[tokenId] = {
               annotations: annotations,
               timestamp: new Date().toISOString()
           };
           
           localStorage.setItem(key, JSON.stringify(allAnnotations));
           return true;
       } catch(e) {
           console.error('Failed to save annotations:', e);
           return false;
       }
   },
   
   loadAnnotations: function(witnessId) {
       try {
           const key = `${this.keys.annotations}_${witnessId}`;
           const serialized = localStorage.getItem(key);
           
           if (!serialized) return {};
           
           return JSON.parse(serialized);
       } catch(e) {
           console.error('Failed to load annotations:', e);
           return {};
       }
   },
   
   updateRecentProjects: function(project) {
       try {
           let recent = [];
           const existing = localStorage.getItem(this.keys.recentProjects);
           
           if (existing) {
               recent = JSON.parse(existing);
           }
           
           // Remove if already exists
           recent = recent.filter(p => p.id !== project.id);
           
           // Add to beginning
           recent.unshift({
               id: project.id,
               name: project.name,
               lastAccessed: new Date().toISOString(),
               witnessCount: project.witnesses.length
           });
           
           // Limit to max
           recent = recent.slice(0, this.maxRecentProjects);
           
           localStorage.setItem(this.keys.recentProjects, JSON.stringify(recent));
       } catch(e) {
           console.error('Failed to update recent projects:', e);
       }
   },
   
   getRecentProjects: function() {
       try {
           const serialized = localStorage.getItem(this.keys.recentProjects);
           return serialized ? JSON.parse(serialized) : [];
       } catch(e) {
           return [];
       }
   },
   
   startAutoSave: function() {
       if (this.autoSaveTimer) {
           clearInterval(this.autoSaveTimer);
       }
       
       this.autoSaveTimer = setInterval(() => {
           if (EPE.currentProject && EPE.currentProject.isDirty) {
               this.saveProject();
               EPE.currentProject.isDirty = false;
               console.log('Auto-saved project');
           }
       }, this.autoSaveInterval);
   },
   
   createBackup: function() {
       try {
           const current = localStorage.getItem(this.keys.currentProject);
           if (current) {
               localStorage.setItem(this.keys.autoSaveBackup, current);
               return true;
           }
       } catch(e) {
           console.error('Failed to create backup:', e);
       }
       return false;
   },
   
   restoreBackup: function() {
       try {
           const backup = localStorage.getItem(this.keys.autoSaveBackup);
           if (backup) {
               localStorage.setItem(this.keys.currentProject, backup);
               this.loadProject();
               EPE.ui.showNotification('Backup restored', 'success');
               return true;
           }
       } catch(e) {
           console.error('Failed to restore backup:', e);
       }
       return false;
   },
   
   checkStorageQuota: function() {
       let totalSize = 0;
       
       for (let key in localStorage) {
           if (key.startsWith('epe_')) {
               totalSize += localStorage.getItem(key).length;
           }
       }
       
       const percentage = (totalSize / this.maxStorageSize) * 100;
       
       if (percentage > 80) {
           EPE.ui.showNotification(
               `Storage ${percentage.toFixed(1)}% full. Consider exporting and clearing old data.`,
               'warning'
           );
       }
       
       return {
           used: totalSize,
           max: this.maxStorageSize,
           percentage: percentage
       };
   },
   
   clearAll: function() {
       if (!confirm('Clear all local data? This cannot be undone.')) {
           return false;
       }
       
       for (let key in localStorage) {
           if (key.startsWith('epe_')) {
               localStorage.removeItem(key);
           }
       }
       
       EPE.currentProject = null;
       EPE.ui.showNotification('All local data cleared', 'success');
       location.reload();
       return true;
   },
   
   exportLocalStorage: function() {
       const data = {};
       
       for (let key in localStorage) {
           if (key.startsWith('epe_')) {
               data[key] = localStorage.getItem(key);
           }
       }
       
       const blob = new Blob([JSON.stringify(data, null, 2)], {
           type: 'application/json'
       });
       
       const url = URL.createObjectURL(blob);
       const a = document.createElement('a');
       a.href = url;
       a.download = `epe_backup_${new Date().toISOString().split('T')[0]}.json`;
       a.click();
       URL.revokeObjectURL(url);
       
       EPE.ui.showNotification('Local storage exported', 'success');
   },
   
   importLocalStorage: function(file) {
       const reader = new FileReader();
       
       reader.onload = function(e) {
           try {
               const data = JSON.parse(e.target.result);
               
               for (let key in data) {
                   if (key.startsWith('epe_')) {
                       localStorage.setItem(key, data[key]);
                   }
               }
               
               EPE.storage.loadProject();
               EPE.ui.showNotification('Local storage imported', 'success');
           } catch(error) {
               EPE.ui.showNotification('Failed to import data', 'error');
           }
       };
       
       reader.readAsText(file);
   }
};

// ========================================
// 4. SIMPLE EXPORT SYSTEM
// ========================================

EPE.exporters = {
   formats: ['txt', 'json', 'html', 'csv', 'tei-basic'],
   
   exportProject: function(format, options = {}) {
       if (!EPE.currentProject) {
           EPE.ui.showNotification('No project to export', 'error');
           return;
       }
       
       let content = '';
       let filename = '';
       let mimeType = 'text/plain';
       
       switch(format) {
           case 'txt':
               content = this.exportToText(options);
               filename = `${EPE.currentProject.id}_export.txt`;
               mimeType = 'text/plain;charset=utf-8';
               break;
               
           case 'json':
               content = this.exportToJSON(options);
               filename = `${EPE.currentProject.id}_export.json`;
               mimeType = 'application/json;charset=utf-8';
               break;
               
           case 'html':
               content = this.exportToHTML(options);
               filename = `${EPE.currentProject.id}_report.html`;
               mimeType = 'text/html;charset=utf-8';
               break;
               
           case 'csv':
               content = this.exportToCSV(options);
               filename = `${EPE.currentProject.id}_alignment.csv`;
               mimeType = 'text/csv;charset=utf-8';
               break;
               
           case 'tei-basic':
               content = this.exportToTEI(options);
               filename = `${EPE.currentProject.id}_tei.xml`;
               mimeType = 'text/xml;charset=utf-8';
               break;
               
           default:
               EPE.ui.showNotification('Unknown export format', 'error');
               return;
       }
       
       // Add to export history
       this.addToExportHistory(format, filename);
       
       // Download file
       this.downloadFile(content, filename, mimeType);
       
       EPE.ui.showNotification(`Exported as ${format.toUpperCase()}`, 'success');
   },
   
   exportToText: function(options = {}) {
       let output = [];
       
       // Header
       output.push('=' .repeat(60));
       output.push(`PROJECT: ${EPE.currentProject.name}`);
       output.push(`EXPORTED: ${new Date().toISOString()}`);
       output.push(`WITNESSES: ${EPE.currentProject.witnesses.length}`);
       output.push('=' .repeat(60));
       output.push('');
       
       // Each witness
       EPE.currentProject.witnesses.forEach(witness => {
           if (options.witnessIds && !options.witnessIds.includes(witness.id)) {
               return;
           }
           
           output.push(`=== WITNESS: ${witness.id} ===`);
           output.push(`Label: ${witness.label}`);
           output.push(`Date: ${witness.date}`);
           output.push(`Folios: ${witness.folios}`);
           output.push(`Status: ${witness.status}`);
           output.push('');
           
           // Text
           if (options.includeText !== false) {
               output.push('TEXT:');
               output.push(witness.text);
               output.push('');
           }
           
           // Tokens
           if (options.includeTokens) {
               output.push('TOKENS:');
               witness.tokens.forEach(token => {
                   output.push(`  ${token.id}: "${token.text}" (${token.type})`);
               });
               output.push('');
           }
           
           output.push('-'.repeat(40));
           output.push('');
       });
       
       // Variants/Apparatus
       if (options.includeApparatus) {
           output.push('=== CRITICAL APPARATUS ===');
           const variants = this.findVariants();
           variants.forEach(variant => {
               output.push(`Position ${variant.position}: ${variant.base} ] ${variant.readings.join(', ')}`);
           });
       }
       
       return output.join('\n');
   },
   
   exportToJSON: function(options = {}) {
       const data = {
           metadata: {
               projectName: EPE.currentProject.name,
               projectId: EPE.currentProject.id,
               exportDate: new Date().toISOString(),
               exportVersion: EPE.version,
               schema: EPE.currentProject.schema
           },
           witnesses: []
       };
       
       EPE.currentProject.witnesses.forEach(witness => {
           if (options.witnessIds && !options.witnessIds.includes(witness.id)) {
               return;
           }
           
           const witnessData = {
               id: witness.id,
               label: witness.label,
               metadata: witness.metadata,
               date: witness.date,
               folios: witness.folios,
               status: witness.status
           };
           
           if (options.includeText !== false) {
               witnessData.text = witness.text;
           }
           
           if (options.includeTokens) {
               witnessData.tokens = witness.tokens;
           }
           
           data.witnesses.push(witnessData);
       });
       
       if (options.includeApparatus) {
           data.apparatus = this.findVariants();
       }
       
       if (options.includeAnnotations) {
           data.annotations = this.gatherAnnotations();
       }
       
       return JSON.stringify(data, null, 2);
   },
   
   exportToHTML: function(options = {}) {
       const html = [];
       
       html.push('<!DOCTYPE html>');
       html.push('<html lang="en" dir="ltr">');
       html.push('<head>');
       html.push('  <meta charset="UTF-8">');
       html.push('  <meta name="viewport" content="width=device-width, initial-scale=1.0">');
       html.push(`  <title>${EPE.currentProject.name} - Export Report</title>`);
       html.push('  <style>');
       html.push('    body { font-family: Georgia, serif; max-width: 900px; margin: 40px auto; padding: 20px; }');
       html.push('    h1 { color: #2563eb; border-bottom: 2px solid #2563eb; padding-bottom: 10px; }');
       html.push('    h2 { color: #1e293b; margin-top: 30px; }');
       html.push('    .witness { margin: 20px 0; padding: 20px; background: #f8fafc; border-left: 4px solid #2563eb; }');
       html.push('    .metadata { display: grid; grid-template-columns: 120px 1fr; gap: 10px; margin: 10px 0; }');
       html.push('    .metadata dt { font-weight: bold; color: #64748b; }');
       html.push('    .text { font-size: 16px; line-height: 1.8; margin: 20px 0; }');
       html.push('    .rtl { direction: rtl; text-align: right; font-family: Vazirmatn, Tahoma, sans-serif; }');
       html.push('    .token { display: inline-block; padding: 2px 4px; margin: 1px; background: #e0e7ff; border-radius: 3px; }');
       html.push('    .variant { background: #fef3c7; }');
       html.push('    .gap { background: #fee2e2; color: #dc2626; font-style: italic; }');
       html.push('    .apparatus { margin-top: 40px; padding: 20px; background: #fefce8; border: 1px solid #facc15; }');
       html.push('    .footer { margin-top: 40px; padding-top: 20px; border-top: 1px solid #e2e8f0; color: #94a3b8; font-size: 12px; }');
       html.push('    @media print { body { margin: 0; } .no-print { display: none; } }');
       html.push('  </style>');
       html.push('</head>');
       html.push('<body>');
       
       // Header
       html.push(`  <h1>${EPE.currentProject.name}</h1>`);
       html.push('  <div class="metadata">');
       html.push(`    <dt>Project Type:</dt><dd>${EPE.currentProject.type}</dd>`);
       html.push(`    <dt>Schema:</dt><dd>${EPE.currentProject.schema}</dd>`);
       html.push(`    <dt>Export Date:</dt><dd>${new Date().toLocaleString()}</dd>`);
       html.push(`    <dt>Total Witnesses:</dt><dd>${EPE.currentProject.witnesses.length}</dd>`);
       html.push('  </div>');
       
       // Witnesses
       html.push('  <h2>Witnesses</h2>');
       EPE.currentProject.witnesses.forEach(witness => {
           const isRTL = witness.metadata.direction === 'rtl';
           
           html.push(`  <div class="witness">`);
           html.push(`    <h3>${witness.label} ${witness.isBase ? '[BASE TEXT]' : ''}</h3>`);
           html.push('    <dl class="metadata">');
           html.push(`      <dt>ID:</dt><dd>${witness.id}</dd>`);
           html.push(`      <dt>Date:</dt><dd>${witness.date}</dd>`);
           html.push(`      <dt>Folios:</dt><dd>${witness.folios}</dd>`);
           html.push(`      <dt>Scribe:</dt><dd>${witness.scribe || 'Unknown'}</dd>`);
           html.push(`      <dt>Origin:</dt><dd>${witness.origin || 'Unknown'}</dd>`);
           html.push(`      <dt>Script:</dt><dd>${witness.script}</dd>`);
           html.push('    </dl>');
           
           if (options.includeText !== false) {
               html.push(`    <div class="text ${isRTL ? 'rtl' : ''}">`);
               
               if (options.includeTokens && witness.tokens) {
                   // Display as tokens
                   witness.tokens.forEach(token => {
                       if (token.type === 'gap') {
                           html.push(`<span class="token gap">[gap]</span>`);
                       } else {
                           html.push(`<span class="token">${this.escapeHtml(token.text)}</span>`);
                       }
                   });
               } else {
                   // Display as plain text
                   html.push(this.escapeHtml(witness.text).replace(/\n/g, '<br>'));
               }
               
               html.push('    </div>');
           }
           
           html.push('  </div>');
       });
       
       // Apparatus
       if (options.includeApparatus) {
           const variants = this.findVariants();
           if (variants.length > 0) {
               html.push('  <div class="apparatus">');
               html.push('    <h2>Critical Apparatus</h2>');
               variants.forEach(variant => {
                   html.push(`    <p><strong>Position ${variant.position}:</strong> `);
                   html.push(`${variant.base} ] ${variant.readings.join(' | ')}</p>`);
               });
               html.push('  </div>');
           }
       }
       
       // Footer
       html.push('  <div class="footer">');
       html.push(`    <p>Generated by EPE ${EPE.version} on ${new Date().toISOString()}</p>`);
       html.push('  </div>');
       
       html.push('</body>');
       html.push('</html>');
       
       return html.join('\n');
   },
   
   exportToCSV: function(options = {}) {
       const csv = [];
       const witnesses = EPE.currentProject.witnesses;
       
       // Find maximum token count
       let maxTokens = 0;
       witnesses.forEach(w => {
           if (w.tokens && w.tokens.length > maxTokens) {
               maxTokens = w.tokens.length;
           }
       });
       
       // Header row
       const header = ['Token_Position', 'Token_ID'];
       witnesses.forEach(w => {
           header.push(w.id);
       });
       csv.push(header.join(','));
       
       // Token rows
       for (let i = 0; i < maxTokens; i++) {
           const row = [i + 1, `T${i + 1}`];
           
           witnesses.forEach(witness => {
               if (witness.tokens && witness.tokens[i]) {
                   const token = witness.tokens[i];
                   // Escape CSV special characters
                   let text = token.text;
                   if (text.includes(',') || text.includes('"') || text.includes('\n')) {
                       text = `"${text.replace(/"/g, '""')}"`;
                   }
                   row.push(text);
               } else {
                   row.push('[absent]');
               }
           });
           
           csv.push(row.join(','));
       }
       
       // Add metadata rows if requested
       if (options.includeMetadata) {
           csv.push('');
           csv.push('METADATA');
           csv.push('Witness_ID,Label,Date,Folios,Status');
           witnesses.forEach(w => {
               csv.push(`${w.id},"${w.label}",${w.date},${w.folios},${w.status}`);
           });
       }
       
       return csv.join('\n');
   },
   
   exportToTEI: function(options = {}) {
       const tei = [];
       
       tei.push('<?xml version="1.0" encoding="UTF-8"?>');
       tei.push('<TEI xmlns="http://www.tei-c.org/ns/1.0">');
       tei.push('  <teiHeader>');
       tei.push('    <fileDesc>');
       tei.push('      <titleStmt>');
       tei.push(`        <title>${this.escapeXml(EPE.currentProject.name)}</title>`);
       tei.push('      </titleStmt>');
       tei.push('      <publicationStmt>');
       tei.push('        <p>Exported from EPE - Edition Production Environment</p>');
       tei.push(`        <date>${new Date().toISOString()}</date>`);
       tei.push('      </publicationStmt>');
       tei.push('      <sourceDesc>');
       tei.push('        <listWit>');
       
       // Witness descriptions
       EPE.currentProject.witnesses.forEach(witness => {
           tei.push(`          <witness xml:id="${witness.id}">`);
           tei.push(`            <msDesc>`);
           tei.push(`              <msIdentifier>`);
           tei.push(`                <idno>${this.escapeXml(witness.label)}</idno>`);
           tei.push(`              </msIdentifier>`);
           tei.push(`              <msContents>`);
           tei.push(`                <p>Date: ${witness.date}</p>`);
           tei.push(`                <p>Folios: ${witness.folios}</p>`);
           tei.push(`              </msContents>`);
           tei.push(`            </msDesc>`);
           tei.push(`          </witness>`);
       });
       
       tei.push('        </listWit>');
       tei.push('      </sourceDesc>');
       tei.push('    </fileDesc>');
       tei.push('  </teiHeader>');
       tei.push('  <text>');
       tei.push('    <body>');
       
       // Base text with apparatus
       const baseWitness = EPE.currentProject.witnesses.find(w => w.isBase) || EPE.currentProject.witnesses[0];
       
       if (baseWitness && baseWitness.tokens) {
           tei.push('      <div>');
           
           baseWitness.tokens.forEach((token, index) => {
               if (token.type === 'gap') {
                   tei.push('        <gap/>');
               } else {
                   // Check for variants
                   const variants = this.findVariantsAtPosition(index);
                   
                   if (variants.length > 0) {
                       tei.push(`        <app>`);
                       tei.push(`          <lem wit="#${baseWitness.id}">${this.escapeXml(token.text)}</lem>`);
                       variants.forEach(v => {
                           tei.push(`          <rdg wit="#${v.witnessId}">${this.escapeXml(v.text)}</rdg>`);
                       });
                       tei.push(`        </app>`);
                   } else {
                       tei.push(`        <w>${this.escapeXml(token.text)}</w>`);
                   }
               }
           });
           
           tei.push('      </div>');
       }
       
       tei.push('    </body>');
       tei.push('  </text>');
       tei.push('</TEI>');
       
       return tei.join('\n');
   },
   
   findVariants: function() {
       const variants = [];
       const witnesses = EPE.currentProject.witnesses;
       const baseWitness = witnesses.find(w => w.isBase) || witnesses[0];
       
       if (!baseWitness || !baseWitness.tokens) return variants;
       
       baseWitness.tokens.forEach((baseToken, position) => {
           const readings = new Map();
           readings.set(baseToken.text, [baseWitness.id]);
           
           witnesses.forEach(witness => {
               if (witness.id === baseWitness.id) return;
               if (!witness.tokens || !witness.tokens[position]) return;
               
               const token = witness.tokens[position];
               if (readings.has(token.text)) {
                   readings.get(token.text).push(witness.id);
               } else {
                   readings.set(token.text, [witness.id]);
               }
           });
           
           if (readings.size > 1) {
               const readingsArray = Array.from(readings.entries());
               variants.push({
                   position: position + 1,
                   base: baseToken.text,
                   readings: readingsArray.filter(r => r[0] !== baseToken.text)
                       .map(r => `${r[0]} (${r[1].join(', ')})`)
               });
           }
       });
       
       return variants;
   },
   
   findVariantsAtPosition: function(position) {
       const variants = [];
       const witnesses = EPE.currentProject.witnesses;
       const baseWitness = witnesses.find(w => w.isBase) || witnesses[0];
       
       if (!baseWitness || !baseWitness.tokens || !baseWitness.tokens[position]) {
           return variants;
       }
       
       const baseToken = baseWitness.tokens[position];
       
       witnesses.forEach(witness => {
           if (witness.id === baseWitness.id) return;
           if (!witness.tokens || !witness.tokens[position]) return;
           
           const token = witness.tokens[position];
           if (token.text !== baseToken.text) {
               variants.push({
                   witnessId: witness.id,
                   text: token.text
               });
           }
       });
       
       return variants;
   },
   
   gatherAnnotations: function() {
       const annotations = {};
       
       EPE.currentProject.witnesses.forEach(witness => {
           const witnessAnnotations = EPE.storage.loadAnnotations(witness.id);
           if (Object.keys(witnessAnnotations).length > 0) {
               annotations[witness.id] = witnessAnnotations;
           }
       });
       
       return annotations;
   },
   
   escapeHtml: function(text) {
       const div = document.createElement('div');
       div.textContent = text;
       return div.innerHTML;
   },
   
   escapeXml: function(text) {
       return text
           .replace(/&/g, '&amp;')
           .replace(/</g, '&lt;')
           .replace(/>/g, '&gt;')
           .replace(/"/g, '&quot;')
           .replace(/'/g, '&apos;');
   },
   
   downloadFile: function(content, filename, mimeType) {
       const blob = new Blob([content], { type: mimeType });
       const url = URL.createObjectURL(blob);
       const a = document.createElement('a');
       a.href = url;
       a.download = filename;
       document.body.appendChild(a);
       a.click();
       document.body.removeChild(a);
       URL.revokeObjectURL(url);
   },
   
   addToExportHistory: function(format, filename) {
       try {
           let history = [];
           const existing = localStorage.getItem(EPE.storage.keys.exportHistory);
           
           if (existing) {
               history = JSON.parse(existing);
           }
           
           history.unshift({
               format: format,
               filename: filename,
               timestamp: new Date().toISOString(),
               projectName: EPE.currentProject.name,
               witnessCount: EPE.currentProject.witnesses.length
           });
           
           // Limit history
           history = history.slice(0, EPE.storage.maxExportHistory);
           
           localStorage.setItem(EPE.storage.keys.exportHistory, JSON.stringify(history));
       } catch(e) {
           console.error('Failed to update export history:', e);
       }
   },
   
   getExportHistory: function() {
       try {
           const serialized = localStorage.getItem(EPE.storage.keys.exportHistory);
           return serialized ? JSON.parse(serialized) : [];
       } catch(e) {
           return [];
       }
   }
};

// ========================================
// 5. UI MANAGEMENT
// ========================================

EPE.ui = {
   elements: {},
   
   init: function() {
       this.cacheElements();
       this.attachEventListeners();
       this.initializeTooltips();
       this.loadSavedState();
       this.updateInterface();
   },
   
   cacheElements: function() {
       this.elements = {
           // Main sections
           sidebar: document.querySelector('.sidebar'),
           workspace: document.querySelector('.workspace'),
           rightPanel: document.querySelector('.right-panel'),
           
           // Witness management
           witnessList: document.querySelector('.witness-list'),
           witnessSearch: document.querySelector('.witness-search'),
           witnessCounter: document.querySelector('.witness-counter'),
           
           // Token display
           alignmentTable: document.querySelector('.alignment-table'),
           tokenDetailPanel: document.querySelector('.token-detail-panel'),
           
           // Controls
           languageSwitch: document.querySelector('.language-switcher'),
           exportModal: document.querySelector('.export-modal'),
           consolePanel: document.querySelector('.console-panel'),
           
           // Status indicators
           statusMessage: document.querySelector('.status-message'),
           progressBar: document.querySelector('.multi-progress'),
           connectionStatus: document.querySelector('.connection-status')
       };
   },
   
   attachEventListeners: function() {
       // Sample project loader
       document.querySelectorAll('[data-load-sample]').forEach(btn => {
           btn.addEventListener('click', (e) => {
               const projectId = e.target.dataset.loadSample;
               EPE.data.loadSampleProject(projectId);
           });
       });
       
       // Export buttons
       document.querySelectorAll('.export-btn').forEach(btn => {
           btn.addEventListener('click', (e) => {
               const format = e.currentTarget.querySelector('.format').textContent.toLowerCase();
               this.showExportDialog(format);
           });
       });
       
       // Tokenization settings
       document.querySelector('#retokenize-btn')?.addEventListener('click', () => {
           if (EPE.currentProject && EPE.currentProject.witnesses.length > 0) {
               EPE.currentProject.witnesses.forEach(w => {
                   EPE.tokenizers.retokenize(w.id);
               });
           }
       });
       
       // Storage management
       document.querySelector('#save-project')?.addEventListener('click', () => {
           EPE.storage.saveProject();
       });
       
       document.querySelector('#clear-storage')?.addEventListener('click', () => {
           EPE.storage.clearAll();
       });
       
       // Console toggle
       document.querySelector('.btn-console')?.addEventListener('click', () => {
           this.elements.consolePanel?.classList.toggle('hidden');
       });
       
       // Keyboard shortcuts
       document.addEventListener('keydown', (e) => {
           // Ctrl+S: Save
           if (e.ctrlKey && e.key === 's') {
               e.preventDefault();
               EPE.storage.saveProject();
           }
           
           // Ctrl+E: Export
           if (e.ctrlKey && e.key === 'e') {
               e.preventDefault();
               this.showExportDialog();
           }
           
           // Ctrl+Z: Undo (placeholder)
           if (e.ctrlKey && e.key === 'z') {
               e.preventDefault();
               this.showNotification('Undo not yet implemented', 'info');
           }
       });
       
       // Window resize
       window.addEventListener('resize', () => {
           this.adjustLayout();
       });
       
       // Before unload warning
       window.addEventListener('beforeunload', (e) => {
           if (EPE.currentProject && EPE.currentProject.isDirty) {
               e.preventDefault();
               e.returnValue = 'You have unsaved changes. Are you sure you want to leave?';
           }
       });
   },
   
   updateWitnessList: function() {
       if (!EPE.currentProject || !this.elements.witnessList) return;
       
       const html = [];
       
       EPE.currentProject.witnesses.forEach(witness => {
           const statusClass = witness.status === 'complete' ? 'aligned' : 
                              witness.status === 'fragment' ? 'partial' : 'empty';
           
           html.push(`
               <div class="witness-item ${witness.isBase ? 'base selected' : ''}" data-witness-id="${witness.id}">
                   <input type="checkbox" ${witness.isBase ? 'checked' : ''}>
                   <span class="witness-status ${statusClass}"></span>
                   <div class="witness-info">
                       <span class="witness-id">${witness.id}</span>
                       <span class="witness-label">${witness.label} ${witness.isBase ? '[BASE]' : ''}</span>
                       <div class="witness-meta">
                           <span>${witness.date}</span>
                           <span>${witness.folios} folios</span>
                           <span>${witness.status}</span>
                       </div>
                   </div>
                   <button class="btn-witness-action">⚙</button>
               </div>
           `);
       });
       
       this.elements.witnessList.innerHTML = html.join('');
       
       // Update counter
       this.updateWitnessCounter();
   },
   
   updateWitnessCounter: function() {
       if (!EPE.currentProject) return;
       
       const total = EPE.currentProject.witnesses.length;
       let tokenCount = 0;
       
       EPE.currentProject.witnesses.forEach(w => {
           if (w.tokens) tokenCount += w.tokens.length;
       });
       
       document.querySelector('.counter-number:nth-child(1)').textContent = total;
       document.querySelector('.counter-number:nth-child(2)').textContent = tokenCount.toLocaleString();
   },
   
   updateMainView: function() {
       if (!EPE.currentProject) return;
       
       // Update alignment table
       this.updateAlignmentTable();
       
       // Update breadcrumb
       this.updateBreadcrumb();
       
       // Update status
       this.updateWorkflowStatus();
   },
   
   updateAlignmentTable: function() {
       if (!EPE.currentProject || !this.elements.alignmentTable) return;
       
       const tbody = this.elements.alignmentTable.querySelector('tbody');
       if (!tbody) return;
       
       const html = [];
       
       EPE.currentProject.witnesses.forEach(witness => {
           const isBase = witness.isBase;
           const rowClass = isBase ? 'witness-row base-text' : 'witness-row';
           
           html.push(`<tr class="${rowClass}">`);
           html.push(`<td class="witness-cell">${witness.label} ${isBase ? '[BASE]' : ''}</td>`);
           
           // Show first 5 tokens as example
           if (witness.tokens) {
               for (let i = 0; i < Math.min(5, witness.tokens.length); i++) {
                   const token = witness.tokens[i];
                   const dir = witness.metadata.direction;
                   
                   if (token.type === 'gap') {
                       html.push(`<td class="token-cell gap">[gap]</td>`);
                   } else {
                       html.push(`<td class="token-cell" dir="${dir}">${token.text}</td>`);
                   }
               }
           }
           
           html.push('</tr>');
       });
       
       tbody.innerHTML = html.join('');
   },
   
   updateBreadcrumb: function() {
       const breadcrumb = document.querySelector('.breadcrumb');
       if (!breadcrumb || !EPE.currentProject) return;
       
       breadcrumb.innerHTML = `
           <span>${EPE.currentProject.name}</span>
           <span>›</span>
           <span>All Witnesses</span>
           <span>›</span>
           <span>Alignment View</span>
       `;
   },
   
   updateWorkflowStatus: function() {
       const hasProject = !!EPE.currentProject;
       const hasTokens = hasProject && EPE.currentProject.witnesses.some(w => w.tokens && w.tokens.length > 0);
       
       document.querySelectorAll('.status-step').forEach(step => {
           step.classList.remove('complete', 'active');
       });
       
       if (hasProject) {
           document.querySelector('.status-step:nth-child(1)').classList.add('complete');
       }
       if (hasTokens) {
           document.querySelector('.status-step:nth-child(2)').classList.add('complete');
           document.querySelector('.status-step:nth-child(3)').classList.add('active');
       }
   },
   
   updateTokenDisplay: function(witnessId) {
       // Update the token display for a specific witness
       this.updateAlignmentTable();
   },
   
   showExportDialog: function(format = 'txt') {
       const modal = document.createElement('div');
       modal.className = 'export-modal-overlay';
       modal.innerHTML = `
           <div class="export-modal-content">
               <h3>Export Project</h3>
               <div class="export-options">
                   <label>
                       <input type="radio" name="export-format" value="txt" ${format === 'txt' ? 'checked' : ''}>
                       Plain Text (.txt)
                   </label>
                   <label>
                       <input type="radio" name="export-format" value="json" ${format === 'json' ? 'checked' : ''}>
                       JSON (.json)
                   </label>
                   <label>
                       <input type="radio" name="export-format" value="html" ${format === 'html' ? 'checked' : ''}>
                       HTML Report (.html)
                   </label>
                   <label>
                       <input type="radio" name="export-format" value="csv" ${format === 'csv' ? 'checked' : ''}>
                       CSV Table (.csv)
                   </label>
                   <label>
                       <input type="radio" name="export-format" value="tei-basic" ${format === 'tei-basic' ? 'checked' : ''}>
                       TEI Basic (.xml)
                   </label>
               </div>
               
               <div class="export-settings">
                   <h4>Options</h4>
                   <label>
                       <input type="checkbox" id="export-include-text" checked>
                       Include witness text
                   </label>
                   <label>
                       <input type="checkbox" id="export-include-tokens">
                       Include tokenization
                   </label>
                   <label>
                       <input type="checkbox" id="export-include-apparatus">
                       Include critical apparatus
                   </label>
                   <label>
                       <input type="checkbox" id="export-include-metadata" checked>
                       Include metadata
                   </label>
               </div>
               
               <div class="modal-actions">
                   <button onclick="EPE.ui.executeExport()">Export</button>
                   <button onclick="this.closest('.export-modal-overlay').remove()">Cancel</button>
               </div>
           </div>
       `;
       
       document.body.appendChild(modal);
       
       // Style the modal
       const style = document.createElement('style');
       style.textContent = `
           .export-modal-overlay {
               position: fixed;
               top: 0;
               left: 0;
               right: 0;
               bottom: 0;
               background: rgba(0,0,0,0.5);
               display: flex;
               align-items: center;
               justify-content: center;
               z-index: 2000;
           }
           .export-modal-content {
               background: white;
               padding: 30px;
               border-radius: 8px;
               width: 500px;
               max-height: 80vh;
               overflow-y: auto;
           }
           .export-modal-content h3 {
               margin-bottom: 20px;
           }
           .export-options label,
           .export-settings label {
               display: block;
               padding: 8px;
               margin: 4px 0;
           }
           .export-settings {
               margin-top: 20px;
               padding-top: 20px;
               border-top: 1px solid #e2e8f0;
           }
           .modal-actions {
               margin-top: 20px;
               display: flex;
               gap: 10px;
               justify-content: flex-end;
           }
           .modal-actions.modal-actions button {
               padding: 8px 20px;
               border: 1px solid #e2e8f0;
               border-radius: 4px;
               cursor: pointer;
           }
           .modal-actions button:first-child {
               background: #2563eb;
               color: white;
               border-color: #2563eb;
           }
       `;
       document.head.appendChild(style);
   },
   
   executeExport: function() {
       const modal = document.querySelector('.export-modal-overlay');
       if (!modal) return;
       
       const format = modal.querySelector('input[name="export-format"]:checked').value;
       const options = {
           includeText: modal.querySelector('#export-include-text').checked,
           includeTokens: modal.querySelector('#export-include-tokens').checked,
           includeApparatus: modal.querySelector('#export-include-apparatus').checked,
           includeMetadata: modal.querySelector('#export-include-metadata').checked
       };
       
       EPE.exporters.exportProject(format, options);
       modal.remove();
   },
   
   showNotification: function(message, type = 'info') {
       const notification = document.createElement('div');
       notification.className = `notification notification-${type}`;
       notification.textContent = message;
       
       // Style
       notification.style.cssText = `
           position: fixed;
           bottom: 80px;
           right: 20px;
           padding: 12px 20px;
           background: ${type === 'success' ? '#16a34a' : 
                        type === 'error' ? '#dc2626' : 
                        type === 'warning' ? '#eab308' : '#2563eb'};
           color: white;
           border-radius: 6px;
           box-shadow: 0 4px 6px rgba(0,0,0,0.1);
           z-index: 3000;
           animation: slideIn 0.3s ease;
       `;
       
       document.body.appendChild(notification);
       
       // Auto remove after 3 seconds
       setTimeout(() => {
           notification.style.animation = 'slideOut 0.3s ease';
           setTimeout(() => notification.remove(), 300);
       }, 3000);
       
       // Add animation styles if not present
       if (!document.querySelector('#notification-animations')) {
           const style = document.createElement('style');
           style.id = 'notification-animations';
           style.textContent = `
               @keyframes slideIn {
                   from { transform: translateX(400px); opacity: 0; }
                   to { transform: translateX(0); opacity: 1; }
               }
               @keyframes slideOut {
                   from { transform: translateX(0); opacity: 1; }
                   to { transform: translateX(400px); opacity: 0; }
               }
           `;
           document.head.appendChild(style);
       }
       
       // Log to console
       this.logToConsole(message, type);
   },
   
   showSaveIndicator: function() {
       const indicator = this.elements.statusMessage;
       if (!indicator) return;
       
       indicator.textContent = `✓ Saved locally ${new Date().toLocaleTimeString()}`;
       indicator.style.color = '#16a34a';
       
       setTimeout(() => {
           indicator.textContent = '✓ Auto-saved 30s ago';
           indicator.style.color = '';
       }, 2000);
   },
   
   logToConsole: function(message, type = 'info') {
       const consoleContent = document.querySelector('.console-content');
       if (!consoleContent) return;
       
       const entry = document.createElement('div');
       entry.className = `log-entry ${type}`;
       entry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
       
       consoleContent.appendChild(entry);
       
       // Keep only last 100 entries
       const entries = consoleContent.querySelectorAll('.log-entry');
       if (entries.length > 100) {
           entries[0].remove();
       }
       
       // Scroll to bottom
       consoleContent.scrollTop = consoleContent.scrollHeight;
   },
   
   initializeTooltips: function() {
       document.querySelectorAll('[title]').forEach(element => {
           element.addEventListener('mouseenter', (e) => {
               const tooltip = document.createElement('div');
               tooltip.className = 'tooltip';
               tooltip.textContent = e.target.title;
               tooltip.style.cssText = `
                   position: absolute;
                   background: #1e293b;
                   color: white;
                   padding: 6px 10px;
                   border-radius: 4px;
                   font-size: 12px;
                   z-index: 4000;
                   pointer-events: none;
                   white-space: nowrap;
               `;
               
               document.body.appendChild(tooltip);
               
               const rect = e.target.getBoundingClientRect();
               tooltip.style.left = rect.left + (rect.width / 2) - (tooltip.offsetWidth / 2) + 'px';
               tooltip.style.top = rect.bottom + 5 + 'px';
               
               e.target._tooltip = tooltip;
               e.target._originalTitle = e.target.title;
               e.target.removeAttribute('title');
           });
           
           element.addEventListener('mouseleave', (e) => {
               if (e.target._tooltip) {
                   e.target._tooltip.remove();
                   e.target.title = e.target._originalTitle;
               }
           });
       });
   },
   
   loadSavedState: function() {
       // Load saved panel sizes
       const savedSizes = EPE.preferences.panelSizes;
       if (savedSizes) {
           // Apply saved sizes
           if (savedSizes.sidebar) {
               document.documentElement.style.setProperty('--sidebar-width', savedSizes.sidebar);
           }
           if (savedSizes.rightPanel) {
               document.documentElement.style.setProperty('--right-panel-width', savedSizes.rightPanel);
           }
       }
       
       // Load language preference
       if (EPE.preferences.language && this.elements.languageSwitch) {
           this.elements.languageSwitch.value = EPE.preferences.language;
       }
   },
   
   adjustLayout: function() {
       // Responsive layout adjustments
       const width = window.innerWidth;
       
       if (width < 1280) {
           document.body.classList.add('compact-layout');
       } else {
           document.body.classList.remove('compact-layout');
       }
       
       if (width < 768) {
           document.body.classList.add('mobile-layout');
       } else {
           document.body.classList.remove('mobile-layout');
       }
   },
   
   updateInterface: function() {
       // Update all UI components
       this.updateWitnessList();
       this.updateMainView();
       this.updateProgressIndicators();
       this.updateConnectionStatus();
   },
   
   updateProgressIndicators: function() {
       if (!EPE.currentProject) return;
       
       const segments = document.querySelectorAll('.progress-segment');
       
       // Calculate progress
       const hasProject = true;
       const hasTokens = EPE.currentProject.witnesses.some(w => w.tokens && w.tokens.length > 0);
       const hasAlignment = false; // Placeholder
       const hasAnnotations = false; // Placeholder
       const hasExport = EPE.exporters.getExportHistory().length > 0;
       
       if (segments[0]) segments[0].style.width = hasProject ? '20%' : '0%';
       if (segments[1]) segments[1].style.width = hasTokens ? '20%' : '0%';
       if (segments[2]) segments[2].style.width = hasAlignment ? '20%' : '10%';
       if (segments[3]) segments[3].style.width = hasAnnotations ? '20%' : '5%';
       if (segments[4]) segments[4].style.width = hasExport ? '20%' : '0%';
   },
   
   updateConnectionStatus: function() {
       const indicators = document.querySelectorAll('.connection-status');
       
       indicators.forEach(indicator => {
           if (indicator.textContent.includes('eScriptorium')) {
               // Check if we have imported data
               const hasImported = EPE.currentProject && EPE.currentProject.witnesses.length > 0;
               indicator.textContent = hasImported ? '● eScriptorium' : '○ eScriptorium';
           }
       });
   },
   
   // Token interaction handlers
   handleTokenClick: function(tokenElement) {
       // Remove previous selection
       document.querySelectorAll('.token.selected').forEach(t => {
           t.classList.remove('selected');
       });
       
       // Add selection
       tokenElement.classList.add('selected');
       
       // Update detail panel
       const tokenId = tokenElement.dataset.id;
       this.updateTokenDetailPanel(tokenId);
   },
   
   updateTokenDetailPanel: function(tokenId) {
       if (!EPE.currentProject) return;
       
       // Find token
       let token = null;
       let witness = null;
       
       for (let w of EPE.currentProject.witnesses) {
           if (w.tokens) {
               token = w.tokens.find(t => t.id === tokenId);
               if (token) {
                   witness = w;
                   break;
               }
           }
       }
       
       if (!token) return;
       
       // Update detail panel
       const panel = this.elements.tokenDetailPanel;
       if (!panel) return;
       
       // Update token ID
       const tokenIdElement = panel.querySelector('.token-id');
       if (tokenIdElement) {
           tokenIdElement.textContent = `Token ID: ${token.globalId || token.id}`;
       }
       
       // Update coordinates
       const coordsElement = panel.querySelector('.detail-group code');
       if (coordsElement) {
           coordsElement.textContent = `Line: ${token.line}, Pos: ${token.position}`;
       }
       
       // Update text fields
       const inputs = panel.querySelectorAll('.detail-input');
       if (inputs[0]) inputs[0].value = token.text;
       if (inputs[1]) inputs[1].value = token.normalized || token.text;
       
       // Show variants
       this.updateVariantDisplay(token, witness);
   },
   
   updateVariantDisplay: function(token, witness) {
       // Find variants at this position
       const variants = EPE.exporters.findVariantsAtPosition(token.sequenceNumber);
       
       const variantList = document.querySelector('.variant-list');
       if (!variantList) return;
       
       if (variants.length > 0) {
           variantList.innerHTML = variants.map(v => 
               `<span class="variant">${v.text} (${v.witnessId})</span>`
           ).join('');
       } else {
           variantList.innerHTML = '<span class="variant">No variants</span>';
       }
   }
};

// ========================================
// 6. INITIALIZATION
// ========================================

document.addEventListener('DOMContentLoaded', function() {
   console.log('EPE Initializing...');
   
   // Initialize storage
   const hasExistingProject = EPE.storage.init();
   
   // Initialize UI
   EPE.ui.init();
   
   // Load sample project if no existing project
   if (!hasExistingProject) {
       // Show welcome message
       EPE.ui.showNotification('Welcome to EPE! Load a sample project to get started.', 'info');
       
       // Create sample loader buttons
       const nav = document.querySelector('.main-nav');
       if (nav) {
           const importBtn = nav.querySelector('.nav-item[href="#"]');
           if (importBtn && importBtn.textContent === 'Import Hub') {
               importBtn.addEventListener('click', (e) => {
                   e.preventDefault();
                   showSampleProjectMenu();
               });
           }
       }
   } else {
       // Project loaded from storage
       EPE.ui.updateInterface();
       EPE.ui.showNotification('Previous project restored', 'success');
   }
   
   // Mark project as clean
   if (EPE.currentProject) {
       EPE.currentProject.isDirty = false;
   }
   
   console.log('EPE Ready');
});

// Sample project menu
function showSampleProjectMenu() {
   const menu = document.createElement('div');
   menu.className = 'sample-menu-overlay';
   menu.innerHTML = `
       <div class="sample-menu-content">
           <h3>Load Sample Project</h3>
           <div class="sample-projects">
               ${EPE.data.samples.projects.map(project => `
                   <div class="sample-project-card" data-project-id="${project.id}">
                       <h4>${project.name}</h4>
                       <p>${project.witnesses.length} witnesses</p>
                       <p>${project.type}</p>
                       <button onclick="loadSampleAndClose('${project.id}')">Load Project</button>
                   </div>
               `).join('')}
           </div>
           <button class="close-menu" onclick="this.closest('.sample-menu-overlay').remove()">Close</button>
       </div>
   `;
   
   // Add styles
   const style = document.createElement('style');
   style.textContent = `
       .sample-menu-overlay {
           position: fixed;
           top: 0;
           left: 0;
           right: 0;
           bottom: 0;
           background: rgba(0,0,0,0.5);
           display: flex;
           align-items: center;
           justify-content: center;
           z-index: 2000;
       }
       .sample-menu-content {
           background: white;
           padding: 30px;
           border-radius: 8px;
           width: 600px;
           max-height: 80vh;
           overflow-y: auto;
       }
       .sample-projects {
           display: grid;
           gap: 15px;
           margin: 20px 0;
       }
       .sample-project-card {
           padding: 15px;
           border: 1px solid #e2e8f0;
           border-radius: 6px;
           transition: all 0.2s ease;
       }
       .sample-project-card:hover {
           border-color: #2563eb;
           box-shadow: 0 2px 8px rgba(0,0,0,0.1);
       }
       .sample-project-card h4 {
           margin: 0 0 10px 0;
           color: #1e293b;
       }
       .sample-project-card p {
           margin: 5px 0;
           color: #64748b;
           font-size: 13px;
       }
       .sample-project-card button {
           margin-top: 10px;
           padding: 6px 12px;
           background: #2563eb;
           color: white;
           border: none;
           border-radius: 4px;
           cursor: pointer;
       }
       .close-menu {
           width: 100%;
           padding: 10px;
           background: #f8fafc;
           border: 1px solid #e2e8f0;
           border-radius: 4px;
           cursor: pointer;
       }
   `;
   document.head.appendChild(style);
   document.body.appendChild(menu);
}

// Load sample and close menu
function loadSampleAndClose(projectId) {
   EPE.data.loadSampleProject(projectId);
   document.querySelector('.sample-menu-overlay')?.remove();
}

// Mark project as dirty when modified
function markProjectDirty() {
   if (EPE.currentProject) {
       EPE.currentProject.isDirty = true;
   }
}

// Export EPE for console access
window.EPE = EPE;

console.log('EPE Core JavaScript loaded successfully');